<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Functional Programing（一) · Who am i?</title><meta name="description" content="Functional Programing（一) - topgrd"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="baidu-site-verification" content="A1EmTvTFQ6"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://topgrd.me/atom.xml" title="Who am i?"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/leezhuo" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/topgrd" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Functional Programing（一)</h1><div class="post-info">Nov 24, 2016</div><div class="post-content"><script src="/assets/js/APlayer.min.js"> </script><p>最近看了函数式编程，传统方式上我们一般是命令式编程，而FP是一种完全不同的编程思想， 他会让你拥有不同的编程体验。<br>在数学上，我们定义一个函数y=f(x)或者y=f(g(x))。当我们输入固定的x值时，函数y的值是一定的。而函数式编程即是这么一种风格，它强调副作用最小，鼓励使用不可变数据和纯函数。在如今的js界，函数式编程变的越来越留下。redux，immutable，Rxjs等都是函数式编程的实践。  </p>
<a id="more"></a>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>何谓纯函数？就是同样的输入，结果永远保持不变（immutable），非纯函数，则同样的输入会导致不同的结果。 在javascript的原生方法中，数组的splice就是非纯函数，因为它会改变原始数组，并将结果返回。而slice则是纯函数，因为它不会改变原始数组，它返回的是新的数组（原数组的副本）。纯函数是不会修改变量，它每次返回都是新的变量或者原始变量的拷贝，他不会修改系统变量，没有副作用。  </p>
<h2 id="函数柯里化-curry"><a href="#函数柯里化-curry" class="headerlink" title="函数柯里化 curry"></a>函数柯里化 curry</h2><p>函数柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> f1 = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y;</div><div class="line"><span class="comment">// 柯里化：</span></div><div class="line"><span class="keyword">const</span> f2 =&gt; <span class="function"><span class="params">x</span> =&gt;</span> (<span class="function"><span class="params">y</span>=&gt;</span> x * y);</div><div class="line"><span class="comment">// example</span></div><div class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> (<span class="function"><span class="params">y</span> =&gt;</span> x+y);</div><div class="line"><span class="keyword">const</span> add2 = add(<span class="number">2</span>);</div><div class="line"><span class="keyword">let</span> result = add2(<span class="number">4</span>); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>上面的例子中我们将函数f1柯里化为f2，f2接受第一个参数x会返回一个函数 <code>x * y</code>，如add2返回的是2 + y，第二次传入y得到最后结果。<br>使用lodash中的curry<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; curry &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line"><span class="keyword">const</span> mutiply = curry(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y);</div><div class="line"><span class="keyword">const</span> mutiply4 = mutiply(<span class="number">4</span>);</div><div class="line"><span class="keyword">let</span> result = mutiply4(<span class="number">6</span>); <span class="comment">// 4 * 6 =24;</span></div></pre></td></tr></table></figure></p>
<p>自己实现一个简陋的curry函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</div><div class="line">  <span class="keyword">var</span> len = fn.length</div><div class="line">  <span class="keyword">var</span> curryFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>)</div><div class="line">    <span class="keyword">if</span> (args.length &lt; len) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> curryFn.apply(<span class="literal">null</span>, slice.call(<span class="built_in">arguments</span>).concat(args))</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> curryFn</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原理是利用闭包保存函数参数，当参数数组长度小于函数长度时，递归，当相等时，调用之前curry的函数，并将递归保存的参数数组赋进去。<br>利用curry向后传递参数的性质可以实现跟踪trace函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trace = curry(<span class="function"><span class="keyword">function</span> (<span class="params">tag, x</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(tag, x)</div><div class="line">    <span class="keyword">return</span> x</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>再利用后面所说的compose将trace函数组合在某一步就可以再函数运行过程中打印想要查看的信息了。</p>
<h2 id="组合-compose"><a href="#组合-compose" class="headerlink" title="组合 compose"></a>组合 compose</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addFour = <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">4</span>;</div><div class="line"><span class="keyword">const</span> addSix = <span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">6</span>;</div><div class="line"><span class="comment">//  简单的compose</span></div><div class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> (<span class="function">(<span class="params">x</span>) =&gt;</span> f(g(x)));</div></pre></td></tr></table></figure>
<p>addFour函数将参数加4，addSix将参数加6，那么addTen呢，是不是应该addFour后addSix？ 上面的compose函数就是组合函数，将函数f和g组合起来。先执行g(x)，然后将g(x)的结果作为f的参数执行。所以addTen方法如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addTen =&gt; compose(addFour, addSix);</div><div class="line">addTen(<span class="number">1</span>); <span class="comment">// 11</span></div></pre></td></tr></table></figure></p>
<p>在 compose 的定义中，g 将先于 f 执行，因此就创建了一个从右到左的数据流。这样做的可读性远远高于嵌套一大堆的函数调用.  是不是很像数学中的函数。</p>
<blockquote>
<p>让代码从右向左运行，而不是由内而外运行，我觉得可以称之为“左倾”.  </p>
</blockquote>
<p>利用reduce实现compose<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span></div><div class="line">  fns.reverse().reduce(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> (...args) =&gt; fn(acc(args)))</div></pre></td></tr></table></figure></p>
<p>使用compose函数就可以将两个，三个，四个等多个函数黏在一起。并让其顺序由右向左运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> addTenTrace = compose(addFour, trace(<span class="string">'after addSix'</span>), addSix)</div><div class="line">addTenTrace(<span class="number">3</span>); <span class="comment">// log: after addSix 9</span></div></pre></td></tr></table></figure></p>
<p>上面利用的就可以跟踪到addSix后函数的运行情况了。  </p>
<h2 id="PointFree"><a href="#PointFree" class="headerlink" title="PointFree"></a>PointFree</h2><p>在FP中，pointfree指的是永远不要说出你的数据，既不暴露数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// not pointfree (提到了word)</span></div><div class="line"><span class="keyword">var</span> snakeCase = <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> word.toLowerCase().replace(<span class="regexp">/\s+/ig</span>, <span class="string">'_'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(snakeCase(<span class="string">'Hello Topgrd'</span>))</div><div class="line"><span class="keyword">var</span> replace = <span class="function"><span class="keyword">function</span> (<span class="params">pattern, replacement</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> word.replace(pattern, replacement)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// pointfree</span></div><div class="line"><span class="keyword">var</span> snakeCase2 = _.compose(replace(<span class="regexp">/\s+/ig</span>, <span class="string">'_'</span>), _.toUpper)</div></pre></td></tr></table></figure></p>
<p>上面两个函数的差异很容易看出来，一个提到了你要处理的数据word，而另一个没有。  </p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/09/16/proxy/" class="prev">PREV</a><a href="/2016/12/01/FP2/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://topgrd.me">topgrd</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>